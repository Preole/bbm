November 26^^th^^, 2013. Status Update
======================================

Parser is officially finished. I've decided to use context-insensitive 
character escape due to ease of understanding & implementation. That way, 
I can begin and end a bold section with literal asterisks without resorting 
to any clever hacks.

The rule's simple: One backslash, one character immediately after, which will 
be treated as plain text regardless of the context. The leading backslash is 
always be discarded.

As for other inline syntaxes, I changed the inline code and code block syntax 
to use typewriter's doublequote '"', instead of the @ sign. The '"' symbol 
feels more literal compared to the noisy @ sign. The bold and Italics syntax 
will stay the same.

I've also implemented block-level pre-formatted paragraph, which is parsed 
and operates the same way as an ordinary paragraph, except all non-leading 
white space and EOL markers are preserved. The syntax works like this:

> A dollar sign, followed by a space, then paragraph. This paragraph 
  will not be terminated until its indentation level falls out of scope, 
  or an aside delimiter or a SeTexT line is found.
  
"""
$ Address:    Some Street Some Avenue Postal Code
  Age:        999
  Gender:     Both
  Hair:       Red
  Occupation: Secret
  
  Song Lyrics:
  
    Line 1     Line 1
    
    
    Line 4     Line 4


Terminated pre-formatted paragraph.
"""

Coming up next, I need to address an ambiguity in the paragraph grammar. 
The definition term (DT), and the pre-formatted (PRE) paragraph can end with 
a Setext header like any other paragraphs. Instead of being promoted to a 
heading element, **''DT'' and ''PRE'' are to remain in their respective node 
types** instead of changing into heading elements.

Note: If viewing this file in source (plain text file .txt), treat two 
consecutive backslashes as a single backslash, and treat single backslash 
followed by any other character as a literal character.



Currently
=========

I'm now working on the semantic analysis portion of the compiler. Unlike 
the prototype, there's more meta data I need to keep track of when I added 
the CSS ID, Class, as well as the internal link syntax. The issues are 
as follows:

- Sectioning {++Rejected++}

- Reference Link & Scoping {++Accepted++}
  
- CSS Class & ID

- Attribute Value Transformation
  
- Dangling Definition Description (DD) and Definition Term (DT)



Sectioning
----------

For each declared header element in the paragraph, an implicit block-level 
container is created. This block level element goes from the header's 
declaration all the way to the next header element that is of equal, or 
higher rank than the current element.
  
**Source code:**

"""
Title
=====

Some preface content.



Section 1
---------

Section 1 content



=== Section 1.1 ===

Section 1.1 content.



Section 2
---------

Section 2 content



Section 3
---------

Section 3 content



=== Section 3.1 ===

Section 3.1 content
"""
  
**Effective HTML Tree:**

"""
<div>
 <h1>Title</h1>
 <p>Some preface content.</p>
 
 <div>
  <h2>Section 1</h2>
  <p>Section 1 content</p>
  
  <div>
   <h3>Section 1.1</h3>
   <p>Section 1.1 content</p>
  </div>
 </div>
 
 <div>
  <h2>Section 2</h2>
  <p>Section 2 content</p>
 </div>
 
 <div>
  <h2>Section 3</h2>
  <p>Section 3 content</p>
  
  <div>
   <h3>Section 3.1</h3>
   <p>Section 3.1 content</p>
  </div>
 </div>
</div>
"""
  
**Translated HTML**

"""
<h1>Title</h1>
<p>Some preface content.</p>
<h2>Section 1</h2>
<p>Section 1 content</p>
<h3>Section 1.1</h3>
<p>Section 1.1 content</p>
<h2>Section 2</h2>
<p>Section 2 content</p>
<h2>Section 3</h2>
<p>Section 3 content</p>
<h3>Section 3.1</h3>
<p>Section 3.1 content</p>
"""
  
However, I'm not sure whether I should represent the effective HTML 
structure in the abstract syntax tree (AST). Doing so helps implementing 
reference link scoping at the cost of adding complexity to the compiler.

I'm not very smart. I think I should leave H1-H6 as they are instead of 
modifying a robust abstract syntax tree.



=== Reference URL & Scoping ===

I should introduce Reference URL scoping, where a Reference Link element is 
only effective within the block element that contains the node. This is 
useful for avoiding namespace collision in long documents, where a large 
number of hyperlinks are present. The following code snippet demonstrates 
the way reference URL scoping works.
  
"""
- List item 1. Boo = "BooURL". ?<Boo>

  :{Boo}: BooURL
  
- List item 2, Boo = "WhackURL". ?<Boo>

  :{Boo}: WhackURL
  
> Blockquote. Boo = "AxeURL". The variable Boo isn't found in the 
  blockquote's scope, so it attempts to search in the container's 
  symbol table, which is the global scope. ?<Boo> 
  
Global paragraph. Boo = "AxeURL". ?<Boo>

Global paragraph. http://www.google.com = "http://www.google.com". 
Since there's no identifier with that name in the document, the hyperlink 
shall use the identifier itself as the URL. ?<http://www.google.com>

:{Boo}: AxeURL
"""
  
In short, when a hyperlink attempts to substitute an identifier with a 
URL, it looks inside its container's symbol table, followed by the 
container's parent, all the way up to the root node. If no such 
substitution can be made, it will use the identifier itself as the URL.

A node is eligible for holding a symbol table of identifiers-to-URL so long 
as it can contain another block element, which is listed inside a short list.

- Table Head, Cell ("""th""", """td""")
- Definition Description ("""dd""")
- Aside blocks ("""div""")
- Bullet list items, ordered list items ("""li""")
- Blockquote ("""blockquote""") 



CSS Class & ID
--------------

The CLASS and ID nodes assign the ID and class value they store to the next 
eligible block-level sibling they encounter. This sounds simple, except that 
there's a lot of clever things the user can do to mangle the document. In 
fact, it's normally a terrible idea letting users assign HTML attribute 
values.
  
One vulnerability is the ID element. In HTML documents, each ID can only 
refer to one element within the document tree, but nothing in BakaBakaMark 
prevents the writer from assigning the same ID multiple times to different 
elements.
  
"""
. id-1
This paragraph has an ID value of """id-1""".

. id-1
This paragraph also has an ID value of """id-1""".
"""
  
If a particular ID has already been declared, All future declaration of that 
ID shall be ignored for processing. This is about the best error-recovery 
I can provide without halting the compiler.
  
"""
<p id="id-1">[...]</p>
<p>[...]</p>
"""
  
Since """id-1""" is already used elsewhere, the second paragraph does 
not get assigned an ID.
  
The other problem is namespace conflict with other pre-defined CSS
class or ID. Specifically, malicious writers can mangle the layout by 
using CSS ID and classes they are not supposed to use.

To solve this issue, add a prefix to all ID and class attributes in the 
compiled document. Then, define these selectors with the prefix, plus a 
few white-listed CSS name templates.
  
; Source

: """
  .. float-left
  ****
  !<Image>-[Alt Text]
  ****
  """
  
; HTML

: """
  <div class="added-prefix-float-left">
  <p><img src="Image" alt="Alt Text"></p>
  </div>
  """
  
The final problem is assignment ambiguity against loose structures such as 
bullet lists. The following code snippet attempts to assign an identifier 
onto a bullet list, which can be assigned to the list item, or the containing 
list.
  
"""
. Identifier
- Bullet 1
- Bullet 2
- Bullet 3
"""
  
In such a case, the identifier should be assigned to the containing 
list, rather than the first individual list item.

"""
<ul id="Identifier">
[...]
</ul>
"""
  
For the really semantically inclined, one may assign the identifier to 
the first block element of a list item. BakaBakaMark can accommodate that 
as well.
  
"""
. Winston Churchill
> . ID
  This paragraph has the identifier "ID".
  
  . ID2
  This paragraph has the identifier "ID2".
  
--->
  
<blockquote id="WinstonChurchill">
<p id="ID">[...]</p>
<p id="ID2">[...]</p>
</blockquote>
"""



For the ''really'' semantically inclined, **There's no way to assign 
identifiers onto individual list items or table cells.**

"""
- Item 1
. ID
- Item 2
- Item 3
"""
  
I can implement this feature, but the prices are source readability and
implementation complications. Seeing an ID element inbetween a bullet list 
makes one think that the bullet list has split up, when in fact, it has not. 
On the other hand, it's highly unlikely that a table cell, a list item, a DD 
element, or a DT element will need to have a CSS class or ID attribute.

The above sample code should break the bullet list into two separate lists, 
with the second list having the ID "ID".
  
"""
<ul>
<li><p>Item 1</p></li>
</ul>

<ul id="ID">
<li><p>Item 2</p></li>
<li><p>Item 3</p></li>
</ul>
"""



Dangling Definition Description 
(DD) and Definition Term (DT)
-------------------------------

If a definition list (DL) begins with one or more DD elements, they should 
be removed from the list.

"""
: Oops. This definition list starts with a DD element.
; Term
: Definition

-->

<dl>
 <dt>Term</dt>
 <dd>Definition<dd>
</dl>
"""

Similarly, trailing DT elements should be removed as well.

"""
; Term
: Definition
; This DL ends with DT.

-->

<dl>
 <dt>Term</dt>
 <dd>Definition<dd>
</dl>
"""

If a definition list has become empty because of this correction, it should 
be removed as well, which means this definition list produces no HTML.

"""
: Definition
; Term
"""



Miscellaneous Algorithms
------------------------

=== HTML Character Transformation ===

The significant HTML character set """' " / > < ` &""" should be replaced 
with their equivalent HTML entities in free flowing text context, such 
as paragraphs. This is the recommendation advised by the OWASP foundation, 
taken from ?<OWASP>-[rule 1] of the web page.

$ & -> &amp;
  ` -> &#x60;
  < -> &lt;
  > -> &gt;
  " -> &quot;
  ' -> &#x27;
  / -> &#x2F;
  
Always replace the ampersand """&""" first before other characters.

:{OWASP}: https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet



=== Attribute Value Transformation ===

; All Attributes

: Remove all ASCII control characters, all extended ASCII control 
  characters, the Unicode Paragraph separator, the Unicode Line Separator, 
  and the """DEL""" character from pressing backspace. I have listed the 
  exact characters to replace in the following grammar.
  
  """
  CTRL
   | [\\u0000-\\u001f] //ASCII Control characters
   | [\\u0080–\\u009f] //Extended ASCII control characters
   | \u007f            //Backspace, or DELETE
   | [\\u2028\\u2029]  //Unicode line and paragraph separators.
   ;
  """
  
  ; Reference Link ID & URL

  : Trim leading and trailing white space characters, including white space 
    from other dialects, which is defined by the following grammar:
    
    """
    SPACE
     | [ \\u2000-\\u200d\\t\\u202f\\u205f​\\u3000\\u1680​]
     | [\\u180e\\u00a0\\u00b7\\u237d\\u2420\\u2422\\u2423]
     ;
    """
     
  ; CSS Classes & ID

  : As __Reference Link ID & URL__, except remove all white space instead.
    These attribute values must also undergo the following processing:

    #. If empty string value after removing WS, discard.
    
    #. If CSS ID & this value has been used before in the document. discard.
    
    #. Apply **HTML Character Transformation**.
    
    #. Add a prefix to the string value.
  
  Finally, apply the **HTML Character Transformation** algorithm.
  
  **Warning**: This replacement scheme is insufficient if the HTML attribute 
  value is unquoted. For more information, read Rule 2 of OWASP's XSS 
  prevention cheat sheet.
   
It's up to the CSS files to implement the appropriate CSS templates needed for 
the presentation effects, and staying conflict-free with other pre-defined 
styles.



//// 
HTML4 Spec:
    
> ID and NAME tokens must begin with a letter ([A-Za-z]) and may be 
  followed by any number of letters, digits ([0-9]), hyphens ("-"), 
  underscores ("_"), colons (":"), and periods (".").
    
HTML5 Spec:
    
> The id attribute specifies its element's unique identifier (ID). 
  The value must be unique amongst all the IDs in the element's home subtree 
  and must contain at least one character. The value must not contain any 
  space characters.
  
:{Paciello}: http://blog.paciellogroup.com/2013/10/html5-document-outline/
:{Berea}: http://www.456bereastreet.com/archive/201205/make_sure_your_html5_document_outline_is_backwards_compatible/
////